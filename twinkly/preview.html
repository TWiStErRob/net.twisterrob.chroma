<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			overflow: hidden;
			margin: 0;
		}
	</style>
</head>
<body>

<script src="https://unpkg.com/@babel/standalone@7.23.6/babel.js"></script>

<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
		}
	}
</script>

<!--suppress JSUnusedGlobalSymbols -->
<script type="text/babel" data-type="module" data-presets="flow">
	// Flow: https://github.com/niieani/typescript-vs-flowtype
	import * as THREE from 'three';
	// TODO Understand what's right: https://threejs.org/docs/#manual/en/introduction/Color-management
	// Stop messing with my RGB values!
	THREE.ColorManagement.enabled = false;
	window.THREE = THREE; // For Chrome console.

	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

	type Coordinate = { x: number, y: number, z: number };
	type TimeoutID = number;

	class Main {
		params = {
			threshold: 0,
			strength: 1,
			radius: 0,
			exposure: 1,
		};

		renderer: THREE.WebGLRenderer;
		camera: THREE.Camera;
		scene: THREE.Scene;
		bloomPass: UnrealBloomPass;
		composer: EffectComposer;

		init() {
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
			document.body.appendChild(renderer.domElement);
			this.renderer = renderer;

			this.camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.01, 200);

			const controls = new OrbitControls(this.camera, renderer.domElement);
			controls.target = new THREE.Vector3(0, 1, 0);
			controls.object.position.set(1, 1.5, 2);
			controls.minDistance = 1;
			controls.maxDistance = 10;
			controls.update();
			controls.addEventListener('change', () => this.render());

			const scene = new THREE.Scene();
			setupScene(scene);
			this.scene = scene;

			const bloomPass = new UnrealBloomPass();
			bloomPass.threshold = this.params.threshold;
			bloomPass.strength = this.params.strength;
			bloomPass.radius = this.params.radius;
			this.bloomPass = bloomPass;

			const target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
				type: THREE.HalfFloatType,
				format: THREE.RGBAFormat,
				colorSpace: THREE.SRGBColorSpace,
				samples: 8,
			});
			const composer = new EffectComposer(renderer, target);
			composer.addPass(new RenderPass(scene, this.camera));
			composer.addPass(new ShaderPass(GammaCorrectionShader));
			composer.addPass(bloomPass);
			this.composer = composer;

			this.setupGui();
		}

		setupGui() {
			const gui = new GUI();

			const bloomFolder = gui.addFolder('bloom');

			const that = this;
			bloomFolder.add(this.params, 'threshold', 0.0, 1.0).onChange(function(value) {
				that.bloomPass.threshold = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'strength', 0.0, 3).onChange(function(value) {
				that.bloomPass.strength = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'radius', 0.0, 1.0).step(0.01).onChange(function(value) {
				that.bloomPass.radius = Number(value);
				that.render();
			});

			const toneMappingFolder = gui.addFolder('tone mapping');

			toneMappingFolder.add(this.params, 'exposure', 0.1, 2).onChange(function(value) {
				that.renderer.toneMappingExposure = Math.pow(value, 4.0);
				that.render();
			});

			const environmentFolder = gui.addFolder('environment');

			environmentFolder.add(LED.geometry.parameters, 'radius', 0, 0.05).step(0.001).onChange(function(value) {
				LED.geometry = new THREE.SphereGeometry(value);
				setupScene(that.scene);
				that.render();
			});
		}

		// noinspection JSUnusedLocalSymbols
		onPointerDown(event: PointerEvent) {
			if (this.hoveredLED) {
				this.hoveredLED.lit = !this.hoveredLED.lit;
				this.render();
			}
		}

		hoveredLED: LED | null = null;

		onPointerMove(event: MouseEvent) {
			const currentObject = this.cast(event);
			if (this.hoveredLED === null && currentObject) {
				this.onEnter(currentObject);
				this.hoveredLED = currentObject;
				this.render();
			} else if (this.hoveredLED !== null  && currentObject === null) {
				const existingObject = this.hoveredLED;
				this.hoveredLED = null;
				this.onExit(existingObject);
				this.render();
			} else if (this.hoveredLED !== null && currentObject && this.hoveredLED !== currentObject) {
				const existingLED = this.hoveredLED;
				this.hoveredLED = null;
				this.onExit(existingLED);
				this.onEnter(currentObject);
				this.hoveredLED = currentObject;
				this.render();
			}
		}

		onEnter(led: LED) {
			//console.log("enter", object);
			led.highlight = true;
		}

		onExit(led: LED) {
			//console.log("exit", object);
			led.highlight = false;
		}

		cast(event: MouseEvent): LED | null {
			const mouse = new THREE.Vector2(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1,
			);

			const raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, this.camera);
			const intersects = raycaster.intersectObjects(this.scene.children, false);
			const leds = intersects.filter((intersect) => intersect.object instanceof LED);
			if (leds.length > 0) {
				return leds[0].object;
			} else {
				return null;
			}
		}

		onResize() {
			const width = window.innerWidth;
			const height = window.innerHeight;

			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();

			this.renderer.setSize(width, height);
			this.composer.setSize(width, height);
			this.render();
		}

		render() {
			this.composer.render();
		}
	}

	class Strip extends THREE.Group {
		strands: Array<Strand>;

		constructor(...strands: Array<Strand>) {
			super();
			this.strands = strands;
			strands.forEach((strand: Strand) => this.add(strand));
		}

		get ledCount(): number {
			return this.strands.reduce((sum, strand) => sum + strand.ledCount, 0);
		}

		get leds(): Array<LED> {
			return this.strands.flatMap((strand) => strand.leds);
		}

		set frame(frame: Frame) {
			this.leds.forEach((led) => led.color = frame.get(led.index));
		}

		set lit(value: boolean) {
			this.leds.forEach((led) => led.lit = value);
		}

		layout(coordinates: Array<Coordinate>) {
			this.strands.forEach((strand) => strand.layout(coordinates));
		}
	}

	class Strand extends THREE.Group {
		wire: Wire;
		lights: LEDs;

		constructor(wire: Wire, lights: LEDs) {
			super();
			this.wire = wire;
			this.lights = lights;
			this.add(wire);
			this.add(lights);
		}

		get ledCount(): number {
			return this.lights.ledCount;
		}

		get leds(): Array<LED> {
			return this.lights.leds;
		}

		layout(coordinates: Array<Coordinate>) {
			this.lights.layout(coordinates);
			this.wire.layout(this.lights, coordinates);
		}
	}


	class Wire extends Line2 {

		constructor() {
			super(
				new LineGeometry(),
				new LineMaterial({
					color: 0x080808,
					linewidth: .001,
				}),
			);
		}

		/**
		 * @return [x,y,z, x,y,z, ...]
		 */
		static curve(points: Array<THREE.Vector3>, divide: number): Array<number> {
			const spline = new THREE.CatmullRomCurve3(points);
			const divisions = Math.round(divide * points.length);
			const point = new THREE.Vector3();
			const positions: Array<number> = [];
			for (let i = 0, l = divisions; i < l; i++) {
				const t = i / l;
				spline.getPoint(t, point);
				positions.push(point.x, point.y, point.z);
			}
			return positions;
		}

		layout(lights: LEDs, coordinates: Array<Coordinate>) {
			const points = lights.leds.map((led) => {
				const c = coordinates[led.index];
				return new THREE.Vector3(c.x, c.y, c.z);
			});
			const positions = Wire.curve(points, 4);
			this.geometry.setPositions(positions);
			this.computeLineDistances();
		}
	}

	class LEDs extends THREE.Group {
		leds: Array<LED>;

		constructor(count: number, baseIndex: number) {
			super();
			this.leds = Array.from({ length: count }, (_, index) => new LED(baseIndex + index));
			this.leds.forEach((led) => this.add(led));
		}

		get ledCount(): number {
			return this.leds.length;
		}

		layout(coordinates: Array<Coordinate>) {
			this.leds.forEach((led) => {
				const coordinate = coordinates[led.index];
				led.position.set(coordinate.x, coordinate.y, coordinate.z);
			});
		}
	}

	class LED extends THREE.Mesh {
		static geometry: THREE.SphereGeometry = new THREE.SphereGeometry(0.015);

		index: number;

		constructor(index: number) {
			if (!(index >= 0)) {
				throw new Error(`Invalid index: ${index}.`);
			}
			super(
				LED.geometry,
				new THREE.MeshStandardMaterial({
					toneMapped: false,
					emissive: new THREE.Color(1, 1, 1),
					emissiveIntensity: 0,
				}),
			);
			this.index = index;
		}

		get color(): THREE.Color {
			return this.material.emissive;
		}

		set color(value: THREE.Color) {
			this.material.emissive = value;
		}

		get lit(): boolean {
			return this.material.emissiveIntensity > 0;
		}

		set lit(value: boolean) {
			this.material.emissiveIntensity = value? 1 : 0;
		}

		get highlight(): boolean {
			return this.material.userData.preHighlightIntensity !== undefined;
		}

		set highlight(value: boolean) {
			if (value) {
				this.material.userData.preHighlightIntensity = this.material.emissiveIntensity;
				this.material.emissiveIntensity = 4;
			} else if (this.highlight) {
				this.material.emissiveIntensity = this.material.userData.preHighlightIntensity;
				delete this.material.userData.preHighlightIntensity;
			}
		}
	}

	class Layout {
		coordinates: Array<Coordinate>;

		constructor(coordinates: Array<Coordinate>) {
			this.coordinates = coordinates;
			this.coordinates.forEach((c: Coordinate) => c.y *= 2);
		}

		apply(strip: Strip) {
			strip.layout(this.coordinates);
		}
	}

	interface Movie {
		get fps(): number;

		get frameCount(): number;

		get(index: number): Frame;
	}

	class StaticMovie implements Movie {
		frames: Array<Frame>;
		_fps: number;

		constructor(frames: Array<Frame>, fps: number) {
			this._fps = fps;
			this.frames = frames;
		}

		get fps(): number {
			return this._fps;
		}

		get frameCount(): number {
			return this.frames.length;
		}

		get(index: number): Frame {
			if (index < 0 || index >= this.frames.length) {
				throw new Error("Index out of bounds.");
			}
			return this.frames[index];
		}
	}

	class Frame {
		colors: Array<THREE.Color>;

		constructor(colors: Array<THREE.Color>) {
			this.colors = colors;
		}

		get(index: number): THREE.Color {
			return this.colors[index];
		}

		static static(ledCount: number, color: THREE.Color): Frame {
			return new Frame(Array.from({ length: ledCount }, () => color.clone()));
		}

		static random(ledCount: number): Frame {
			return new Frame(Array.from({ length: ledCount }, () => {
				const color = new THREE.Color();
				color.setHSL(Math.random(), 0.7, Math.random() * 0.2 + 0.05);
				return color;
			}));
		}
	}

	class MoviePlayer {
		movie: Movie;
		index: FrameStepper;
		strip: Strip;
		running: TimeoutID | undefined;
		onNext: () => void;

		constructor(strip: Strip, onNext: () => void, movie: Movie) {
			this.movie = movie;
			this.onNext = onNext;
			this.index = new FrameStepper(movie.frameCount);
			this.strip = strip;
		}

		get current(): Frame {
			return this.movie.get(this.index.current);
		}

		next() {
			this.index.next();
			this.strip.frame = this.current;
			this.onNext();
			this.running = setTimeout(() => this.next(), 1000 / this.movie.fps);
		}

		start() {
			this.strip.lit = true;
			this.next();
		}

		stop() {
			clearTimeout(this.running);
			this.running = undefined;
		}
	}

	class FrameStepper {
		frameIndex: number;
		frameCount: number;

		constructor(frameCount: number) {
			if (frameCount <= 0) {
				throw new Error("Frame count must be positive.");
			}
			this.frameCount = frameCount;
			this.frameIndex = -1;
		}

		get current(): number {
			if (this.frameIndex < 0) {
				throw new Error("Not started.");
			}
			return this.frameIndex;
		}

		next(): number {
			this.frameIndex = (this.frameIndex + 1) % this.frameCount;
			return this.frameIndex;
		}
	}

	class RawMovie {
		data: Uint8Array;

		constructor(data: Uint8Array) {
			this.data = data;
		}

		toMovie(ledCount: number, fps: number): StaticMovie {
			const frameSize = 3 * ledCount;
			const frameCount = this.data.length / frameSize;
			return new StaticMovie(
				Array.from({ length: frameCount }, (_, index) => {
					const rgbs = this.data.slice(index * frameSize, (index + 1) * frameSize);
					const colors = Array.from({ length: ledCount }, (_, index) => {
						// noinspection PointlessArithmeticExpressionJS
						return new THREE.Color(
							rgbs[index * 3 + 0] / 255.0,
							rgbs[index * 3 + 1] / 255.0,
							rgbs[index * 3 + 2] / 255.0,
						);
					});
					return new Frame(colors);
				}),
				fps,
			);
		}
	}

	function setupScene(scene: THREE.Scene) {
		scene.clear();
		createAxes().forEach((obj) => scene.add(obj));
		scene.add(new THREE.AmbientLight(0x101010));
		//scene.add(buildBox());
		const strip = new Strip(
			new Strand(new Wire(), new LEDs(100, 0)),
			new Strand(new Wire(), new LEDs(100, 100)),
		);
		scene.add(strip);
		loadLayout(strip, "layouts/christmas-2023-detailed3d.json")
			.then(() => {
				//strip.frame = Frame.random(strip.ledCount);
				//strip.lit = true;
				//main.render();

				//startMovie(strip, "movies/generated-heart.raw");

				const movie = generateHeartMovie(strip, scene);
				const player = new MoviePlayer(strip, main.render.bind(main), movie);
				player.start();
				//saveByteArray("heart.raw", toRaw(movie));
			});
	}

	function buildBox(): THREE.LineSegments {
		let geometry = new THREE.BoxGeometry(1, 1, 1);
		geometry.translate(0, 0.5, 0);
		let edges = new THREE.EdgesGeometry(geometry);
		let material = new THREE.LineBasicMaterial({ color: 0x444444 });
		return new THREE.LineSegments(edges, material);
	}

	function loadLayout(strip: Strip, path: string): Promise<void> {
		return fetch(path)
			.then((response) => response.json())
			.then((data) => {
				const layout = new Layout(data);
				layout.apply(strip);
				main.render();
			})
			;
	}

	function startMovie(strip: Strip, path: string) {
		fetch(path)
			.then((response) => response.arrayBuffer())
			.then((data) => {
				const movie = new RawMovie(new Uint8Array(data)).toMovie(strip.ledCount, 15);
				const player = new MoviePlayer(strip, main.render.bind(main), movie);
				player.start();
			})
		;
	}

	function generateRandomMovie(strip: Strip) {
		// noinspection JSUnusedLocalSymbols
		const player = new MoviePlayer(strip, main.render.bind(main), {
			get fps(): number {
				return 15;
			},

			get frameCount(): number {
				return 100;
			},

			get(index: number): Frame {
				return Frame.random(strip.ledCount);
			},
		});
		player.start();
	}

	function isInside(raycaster: THREE.Raycaster, object: THREE.Object3D, point: THREE.Vector3): boolean {
		raycaster.set(point, new THREE.Vector3(1, 1, 1));
		const intersects = raycaster.intersectObject(object, false);
		return intersects.length % 2 === 1;
	}

	function generateHeartMovie(strip: Strip, scene: THREE.Scene): Movie {
		const heart = new THREE.Group();
		const collision = new THREE.Mesh(
			new THREE.SphereGeometry(0.60, 12, 12),
			new THREE.MeshBasicMaterial({
				side: THREE.DoubleSide,
				visible: false,
			}),
		);
		heart.add(collision);
		heart.add(new THREE.LineSegments(
			new THREE.EdgesGeometry(collision.geometry),
			new THREE.LineBasicMaterial({
				color: 0xffff00,
				opacity: 0.05,
				transparent: true,
			}),
		));
		heart.add(new THREE.Mesh(
			new THREE.SphereGeometry(0.01),
			new THREE.MeshBasicMaterial({
				color: 0x00ff00,
			}),
		));
		heart.position.set(0, 0.6, 0);
		// mesh.visible = false;
		scene.add(heart);
		return {
			get fps(): number {
				return 40;
			},

			get frameCount(): number {
				return 50;
			},

			get(index: number): Frame {
				const frame = Frame.static(strip.ledCount, new THREE.Color(0xff7811));
				const raycaster = new THREE.Raycaster();
				const rMax = 0.65;
				heart.scale.set(rMax, rMax, rMax);
				heart.updateWorldMatrix(false, true);
				strip.leds
					.filter((led) => isInside(raycaster, collision, led.position))
					.forEach((led) => {
						frame.colors[led.index] = new THREE.Color(0, 0, 0);
					})
				;
				const r = 0.35 + 0.30 * Math.sin((index / this.frameCount) * 2 * 3.14);
				heart.scale.set(r, r, r);
				heart.updateWorldMatrix(false, true);
				strip.leds
					.filter((led) => isInside(raycaster, collision, led.position))
					.forEach((led) => {
						frame.colors[led.index] = new THREE.Color(0.5, 0, 0);
					})
				;
				return frame;
			},
		};
	}

	function toRaw(movie: Movie): Uint8Array {
		const result = new Uint8Array(movie.frameCount * movie.get(0).colors.length * 3);
		for (let i = 0; i < movie.frameCount; i++) {
			const frame = movie.get(i);
			for (let c = 0; c < frame.colors.length; c++) {
				const color = frame.colors[c];
				// noinspection PointlessArithmeticExpressionJS
				result[(i * frame.colors.length + c) * 3 + 0] = Math.round(color.r * 255);
				result[(i * frame.colors.length + c) * 3 + 1] = Math.round(color.g * 255);
				result[(i * frame.colors.length + c) * 3 + 2] = Math.round(color.b * 255);
			}
		}
		return result;
	}

	// TODO get and send to strip directly: https://xled-docs.readthedocs.io/en/latest/rest_api.html
	function saveByteArray(fileName: string, byte: Uint8Array) {
		const link = document.createElement('a');
		link.href = window.URL.createObjectURL(new Blob([ byte ], { type: "application/pdf" }));
		link.download = fileName;
		link.click();
	}

	function createAxes(): Array<THREE.AxesHelper> {
		let positive = new THREE.AxesHelper(2);
		positive.material.transparent = true;
		positive.material.opacity = .01;
		let negative = new THREE.AxesHelper(2);
		negative.scale.set(-1, -1, -1);
		negative.material.vertexColors = false;
		negative.material.transparent = true;
		negative.material.opacity = .01;
		return [ positive, negative ];
	}

	let main = new Main();
	main.init();
	window.onresize = () => main.onResize();
	window.addEventListener('pointerdown', (event) => main.onPointerDown(event));
	window.addEventListener("mousemove", (event) => main.onPointerMove(event));
	main.render();
</script>
</body>
</html>

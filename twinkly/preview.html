<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			overflow: hidden;
			margin: 0;
		}
	</style>
</head>
<body>
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
		}
	}
</script>

<script type="x-shader/x-vertex" id="vertexshader">
	varying vec2 vUv;
	void main() {
		vUv = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
	uniform sampler2D baseTexture;
	uniform sampler2D bloomTexture;
	varying vec2 vUv;
	void main() {
		gl_FragColor = texture2D(baseTexture, vUv) + vec4(1.0) * texture2D(bloomTexture, vUv);
	}
</script>

<script type="module">
	import * as THREE from 'three';

	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

	const BLOOM_SCENE = 1;

	class Main {
		darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
		materials = {};
		params = {
			threshold: 0,
			strength: 1.1,
			radius: 0,
			exposure: 1.1,
		};

		init() {
			const bloomLayer = new THREE.Layers();
			bloomLayer.set(BLOOM_SCENE);
			this.bloomLayer = bloomLayer;

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			document.body.appendChild(renderer.domElement);
			this.renderer = renderer;

			const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 200);
			camera.position.set(0, 0, 20);
			camera.lookAt(0, 0, 0);
			this.camera = camera;

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 100;
			controls.addEventListener('change', () => this.render());

			const scene = new THREE.Scene();
			setupScene(scene);
			this.scene = scene;
			const renderScene = new RenderPass(scene, camera);

			const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
			bloomPass.threshold = this.params.threshold;
			bloomPass.strength = this.params.strength;
			bloomPass.radius = this.params.radius;
			this.bloomPass = bloomPass;

			const bloomComposer = new EffectComposer(renderer);
			bloomComposer.renderToScreen = false;
			bloomComposer.addPass(renderScene);
			bloomComposer.addPass(bloomPass);
			this.bloomComposer = bloomComposer;

			const mixPass = new ShaderPass(
				new THREE.ShaderMaterial({
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture },
					},
					vertexShader: document.getElementById('vertexshader').textContent,
					fragmentShader: document.getElementById('fragmentshader').textContent,
					defines: {},
				}),
				'baseTexture',
			);
			mixPass.needsSwap = true;

			const outputPass = new OutputPass();

			const finalComposer = new EffectComposer(renderer);
			finalComposer.addPass(renderScene);
			finalComposer.addPass(mixPass);
			finalComposer.addPass(outputPass);
			this.finalComposer = finalComposer;

			this.setupGui();
		}

		setupGui() {
			const gui = new GUI();

			const bloomFolder = gui.addFolder('bloom');

			const that = this;
			bloomFolder.add(this.params, 'threshold', 0.0, 1.0).onChange(function(value) {
				that.bloomPass.threshold = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'strength', 0.0, 3).onChange(function(value) {
				that.bloomPass.strength = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'radius', 0.0, 1.0).step(0.01).onChange(function(value) {
				that.bloomPass.radius = Number(value);
				that.render();
			});

			const toneMappingFolder = gui.addFolder('tone mapping');

			toneMappingFolder.add(this.params, 'exposure', 0.1, 2).onChange(function(value) {
				that.renderer.toneMappingExposure = Math.pow(value, 4.0);
				that.render();
			});
		}

		onPointerDown(event) {
			const mouse = new THREE.Vector2(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1,
			);

			const raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, this.camera);
			const intersects = raycaster.intersectObjects(this.scene.children, false);
			if (intersects.length > 0) {
				/** @type {Bulb} */
				const object = intersects[0].object.domain;
				object.bloom(!object.bloom);
				this.render();
			}
		}

		onResize() {
			const width = window.innerWidth;
			const height = window.innerHeight;

			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();

			this.renderer.setSize(width, height);

			this.bloomComposer.setSize(width, height);
			this.finalComposer.setSize(width, height);

			this.render();
		}

		render() {
			this.scene.traverse((obj) => this.darkenNonBloomed(obj));
			this.bloomComposer.render();
			this.scene.traverse((obj) => this.restoreMaterial(obj));

			// render the entire scene, then render bloom scene on top
			this.finalComposer.render();
		}

		darkenNonBloomed(obj) {
			if (obj.isMesh && this.bloomLayer.test(obj.layers) === false) {
				this.materials[obj.uuid] = obj.material;
				obj.material = this.darkMaterial;
			}
		}

		restoreMaterial(obj) {
			if (this.materials[obj.uuid]) {
				obj.material = this.materials[obj.uuid];
				delete this.materials[obj.uuid];
			}
		}
	}

	class Bulb {
		static geometry = new THREE.SphereGeometry();
		constructor() {
			const color = new THREE.Color();
			color.setHSL(Math.random(), 0.7, Math.random() * 0.2 + 0.05);

			this.material = new THREE.MeshBasicMaterial({ color: color });
			this.sphere = new THREE.Mesh(Bulb.geometry, this.material);
			this.sphere.position.x = Math.random() * 10 - 5;
			this.sphere.position.y = Math.random() * 10 - 5;
			this.sphere.position.z = Math.random() * 10 - 5;
			this.sphere.position.normalize().multiplyScalar(Math.random() * 4.0 + 2.0);
		}

		get color() {
			return this.material.color;
		}
		set color(value) {
			this.material.color = value;
		}

		get object() {
			return this.sphere;
		}

		set bloom(value) {
			if (value) {
				this.sphere.layers.enable(BLOOM_SCENE);
			} else {
				this.sphere.layers.disable(BLOOM_SCENE);
			}
		}
	}

	function setupScene(scene) {
		scene.traverse(disposeMaterial);
		scene.children.length = 0;

		for (let i = 0; i < 50; i++) {
			let bulb = new Bulb();
			scene.add(bulb.object);
			bulb.bloom = Math.random() < 0.25;
		}
	}

	function disposeMaterial(obj) {
		if (obj.material) {
			obj.material.dispose();
		}
	}

	let main = new Main();
	main.init();
	window.onresize = () => main.onResize();
	window.addEventListener('pointerdown', (event) => main.onPointerDown(event));
	main.render();
</script>
</body>
</html>

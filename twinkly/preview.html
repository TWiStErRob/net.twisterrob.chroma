<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			overflow: hidden;
			margin: 0;
		}
	</style>
</head>
<body>
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
		}
	}
</script>

<script type="module">
	"use strict";
	import * as THREE from 'three';
	// TODO Understand what's right: https://threejs.org/docs/#manual/en/introduction/Color-management
	// Stop messing with my RGB values!
	THREE.ColorManagement.enabled = false;
	window.THREE = THREE; // For Chrome console.

	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

	class Main {
		params = {
			threshold: 0,
			strength: 1,
			radius: 0,
			exposure: 1,
		};

		init() {
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
			document.body.appendChild(renderer.domElement);
			this.renderer = renderer;

			this.camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.01, 200);

			const controls = new OrbitControls(this.camera, renderer.domElement);
			controls.target = new THREE.Vector3(0, 1, 0);
			controls.object.position.set(1, 1.5, 2);
			controls.minDistance = 1;
			controls.maxDistance = 10;
			controls.update();
			controls.addEventListener('change', () => this.render());

			const scene = new THREE.Scene();
			setupScene(scene);
			this.scene = scene;

			const bloomPass = new UnrealBloomPass();
			bloomPass.threshold = this.params.threshold;
			bloomPass.strength = this.params.strength;
			bloomPass.radius = this.params.radius;
			this.bloomPass = bloomPass;

			const target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
				type: THREE.HalfFloatType,
				format: THREE.RGBAFormat,
				colorSpace: THREE.SRGBColorSpace,
				samples: 8,
			});
			const composer = new EffectComposer(renderer, target);
			composer.addPass(new RenderPass(scene, this.camera));
			composer.addPass(new ShaderPass(GammaCorrectionShader));
			composer.addPass(bloomPass);
			this.composer = composer;

			this.setupGui();
		}

		setupGui() {
			const gui = new GUI();

			const bloomFolder = gui.addFolder('bloom');

			const that = this;
			bloomFolder.add(this.params, 'threshold', 0.0, 1.0).onChange(function(value) {
				that.bloomPass.threshold = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'strength', 0.0, 3).onChange(function(value) {
				that.bloomPass.strength = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'radius', 0.0, 1.0).step(0.01).onChange(function(value) {
				that.bloomPass.radius = Number(value);
				that.render();
			});

			const toneMappingFolder = gui.addFolder('tone mapping');

			toneMappingFolder.add(this.params, 'exposure', 0.1, 2).onChange(function(value) {
				that.renderer.toneMappingExposure = Math.pow(value, 4.0);
				that.render();
			});

			const environmentFolder = gui.addFolder('environment');

			environmentFolder.add(LED.geometry.parameters, 'radius', 0, 0.05).step(0.001).onChange(function(value) {
				LED.geometry = new THREE.SphereGeometry(value);
				setupScene(that.scene);
				that.render();
			});
		}

		onPointerDown(event) {
			if (this.hoveredLED) {
				this.hoveredLED.lit = !this.hoveredLED.lit;
				this.render();
			}
		}

		/** @type {LED|null} */
		hoveredLED = null;

		onPointerMove(event) {
			const currentObject = this.cast(event);
			if (this.hoveredLED === null && currentObject) {
				this.onEnter(currentObject);
				this.hoveredLED = currentObject;
				this.render();
			} else if (this.hoveredLED !== null && currentObject === null) {
				const existingObject = this.hoveredLED;
				this.hoveredLED = null;
				this.onExit(existingObject);
				this.render();
			} else if (this.hoveredLED !== null && currentObject !== null && this.hoveredLED !== currentObject) {
				const existingLED = this.hoveredLED;
				this.hoveredLED = null;
				this.onExit(existingLED);
				this.onEnter(currentObject);
				this.hoveredLED = currentObject;
				this.render();
			}
		}

		/** @param led {LED} */
		onEnter(led) {
			//console.log("enter", object);
			led.highlight = true;
		}

		/** @param led {LED} */
		onExit(led) {
			//console.log("exit", object);
			led.highlight = false;
		}

		cast(event) {
			const mouse = new THREE.Vector2(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1,
			);

			const raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, this.camera);
			const intersects = raycaster.intersectObjects(this.scene.children, false);
			const leds = intersects.filter((intersect) => intersect.object instanceof LED);
			if (leds.length > 0) {
				return leds[0].object;
			} else {
				return null;
			}
		}

		onResize() {
			const width = window.innerWidth;
			const height = window.innerHeight;

			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();

			this.renderer.setSize(width, height);
			this.composer.setSize(width, height);
			this.render();
		}

		render() {
			this.composer.render();
		}
	}

	class Strip extends THREE.Group {
		/** @type {Array<Strand>} */
		strands;

		constructor(...strands) {
			super();
			this.strands = strands;
			strands.forEach((strand) => this.add(strand));
		}

		get ledCount() {
			return this.strands.reduce((sum, strand) => sum + strand.ledCount, 0);
		}

		get leds() {
			return this.strands.flatMap((strand) => strand.leds);
		}

		/**
		 * @param {Frame} frame
		 */
		set frame(frame) {
			this.leds.forEach((led) => led.color = frame.get(led.index));
		}

		set lit(value) {
			this.leds.forEach((led) => led.lit = value);
		}

		/**
		 * @param {Array<{x: number, y: number, z: number}>} coordinates
		 */
		layout(coordinates) {
			this.strands.forEach((strand) => strand.layout(coordinates));
		}
	}

	class Strand extends THREE.Group {
		/** @type {Wire} */
		wire;

		/** @type {LEDs} */
		lights;

		constructor(wire, lights) {
			super();
			this.wire = wire;
			this.lights = lights;
			this.add(wire);
			this.add(lights);
		}

		get ledCount() {
			return this.lights.ledCount;
		}

		get leds() {
			return this.lights.leds;
		}

		/**
		 * @param {Array<{x: number, y: number, z: number}>} coordinates
		 */
		layout(coordinates) {
			this.lights.layout(coordinates);
			this.wire.layout(this.lights, coordinates);
		}
	}


	class Wire extends Line2 {

		constructor() {
			super(
				new LineGeometry(),
				new LineMaterial({
					color: 0x080808,
					linewidth: .001,
				}),
			);
		}

		/**
		 * @param {Array<THREE.Vector3>} points
		 * @param {Number} divide
		 * @return {Array<Number>} [x,y,z, x,y,z, ...]
		 */
		static curve(points, divide) {
			const spline = new THREE.CatmullRomCurve3(points);
			const divisions = Math.round(divide * points.length);
			const point = new THREE.Vector3();
			const positions = [];
			for (let i = 0, l = divisions; i < l; i++) {
				const t = i / l;
				spline.getPoint(t, point);
				positions.push(point.x, point.y, point.z);
			}
			return positions;
		}

		/**
		 * @param {LEDs} lights
		 * @param {Array<{x: number, y: number, z: number}>} coordinates
		 */
		layout(lights, coordinates) {
			const points = lights.leds.map((led) => {
				const c = coordinates[led.index];
				return new THREE.Vector3(c.x, c.y, c.z);
			});
			const positions = Wire.curve(points, 4);
			this.geometry.setPositions(positions);
			this.computeLineDistances();
		}
	}

	class LEDs extends THREE.Group {
		/** @type {Array<LED>} */
		leds;

		constructor(count, baseIndex) {
			super();
			this.leds = Array.from({ length: count }, (_, index) => new LED(baseIndex + index));
			this.leds.forEach((led) => this.add(led));
		}

		get ledCount() {
			return this.leds.length;
		}

		/**
		 * @param {Array<{x: number, y: number, z: number}>} coordinates
		 */
		layout(coordinates) {
			this.leds.forEach((led) => {
				const coordinate = coordinates[led.index];
				led.position.set(coordinate.x, coordinate.y, coordinate.z);
			});
		}
	}

	class LED extends THREE.Mesh {
		static geometry = new THREE.SphereGeometry(0.015);

		/** @type {number} */
		index;

		/**
		 * @param {number} index
		 */
		constructor(index) {
			if (!(index >= 0)) {
				throw new Error(`Invalid index: ${index}.`);
			}
			super(
				LED.geometry,
				new THREE.MeshStandardMaterial({
					toneMapped: false,
					emissive: new THREE.Color(1, 1, 1),
					emissiveIntensity: 0,
				}),
			);
			this.index = index;
		}

		/**
		 * @return {THREE.Color}
		 */
		get color() {
			return this.material.emissive;
		}

		/**
		 * @param {THREE.Color} value
		 */
		set color(value) {
			this.material.emissive = value;
		}

		/**
		 * @return {boolean}
		 */
		get lit() {
			return this.material.emissiveIntensity > 0;
		}

		/**
		 * @param {boolean} value
		 */
		set lit(value) {
			this.material.emissiveIntensity = value? 1 : 0;
		}

		/**
		 * @return {boolean}
		 */
		get highlight() {
			return this.material.userData.preHighlightIntensity !== undefined;
		}

		/**
		 * @param {boolean} value
		 */
		set highlight(value) {
			if (value) {
				this.material.userData.preHighlightIntensity = this.material.emissiveIntensity;
				this.material.emissiveIntensity = 4;
			} else if (this.highlight) {
				this.material.emissiveIntensity = this.material.userData.preHighlightIntensity;
				delete this.material.userData.preHighlightIntensity;
			}
		}
	}

	class Layout {
		/**
		 * @type {Array<{x: number, y: number, z: number}>}
		 */
		coordinates;

		/**
		 * @param {Array<{x: number, y: number, z: number}>} coordinates
		 */
		constructor(coordinates) {
			this.coordinates = coordinates;
			this.coordinates.forEach((c) => c.y *= 2);
		}

		/**
		 * @param {Strip} strip
		 */
		apply(strip) {
			strip.layout(this.coordinates);
		}
	}

	class Movie {

		/**
		 * @return {number}
		 */
		get fps() {
			throw new Error("Abstract, not implemented.");
		}

		/**
		 * @return {number}
		 */
		get frameCount() {
			throw new Error("Abstract, not implemented.");
		}

		/**
		 * @param {number} index
		 * @return {Frame}
		 */
		get(index) {
			throw new Error("Abstract, not implemented.");
		}
	}

	class StaticMovie extends Movie {
		/** @type {Array<Frame>} */
		frames;

		constructor(frames, fps) {
			super();
			this._fps = fps;
			this.frames = frames;
		}

		get fps() {
			return this._fps;
		}

		get frameCount() {
			return this.frames.length;
		}

		get(index) {
			if (index < 0 || index >= this.frames.length) {
				throw new Error("Index out of bounds.");
			}
			return this.frames[index];
		}
	}

	class Frame {
		/** @type {Array<THREE.Color>} */
		colors;

		constructor(colors) {
			this.colors = colors;
		}

		get(index) {
			return this.colors[index];
		}

		/**
		 * @param {number} ledCount
		 * @param {THREE.Color} color
		 * @return {Frame}
		 */
		static static(ledCount, color) {
			return new Frame(Array.from({ length: ledCount }, () => color.clone()));
		}

		/**
		 * @param {number} ledCount
		 * @return {Frame}
		 */
		static random(ledCount) {
			return new Frame(Array.from({ length: ledCount }, (_, index) => {
				const color = new THREE.Color();
				color.setHSL(Math.random(), 0.7, Math.random() * 0.2 + 0.05);
				return color;
			}));
		}
	}

	class MoviePlayer {
		/** @type {Movie} */
		movie;

		/** @type {FrameStepper} */
		index;

		/** @type {Strip} */
		strip;

		/** @type {number|undefined} */
		running;

		/** @type {function} */
		onNext;

		/**
		 * @param {Strip} strip
		 * @param {function} onNext
		 * @param {Movie} movie
		 */
		constructor(strip, onNext, movie) {
			this.movie = movie;
			this.onNext = onNext;
			this.index = new FrameStepper(movie.frameCount);
			this.strip = strip;
		}

		/**
		 * @return {Frame}
		 */
		get current() {
			return this.movie.get(this.index.current);
		}

		/**
		 * @return {void}
		 */
		next() {
			this.index.next();
			this.strip.frame = this.current;
			this.onNext();
			this.running = setTimeout(() => this.next(), 1000 / this.movie.fps);
		}

		start() {
			this.strip.lit = true;
			this.next();
		}

		stop() {
			clearTimeout(this.running);
			this.running = undefined;
		}
	}

	class FrameStepper {
		/** @type {number} */
		frameIndex;

		/** @type {number} */
		frameCount;

		/**
		 * @param {number} frameCount
		 */
		constructor(frameCount) {
			if (frameCount <= 0) {
				throw new Error("Frame count must be positive.");
			}
			this.frameCount = frameCount;
			this.frameIndex = -1;
		}

		/**
		 * @return {number}
		 */
		get current() {
			if (this.frameIndex < 0) {
				throw new Error("Not started.");
			}
			return this.frameIndex;
		}

		/**
		 * @return {number}
		 */
		next() {
			this.frameIndex = (this.frameIndex + 1) % this.frameCount;
			return this.frameIndex;
		}
	}

	class RawMovie {
		/** @type {Uint8Array} */
		data;

		/**
		 * @param {Uint8Array} data
		 */
		constructor(data) {
			this.data = data;
		}

		/**
		 * @return {StaticMovie}
		 */
		toMovie(ledCount, fps) {
			const frameSize = 3 * ledCount;
			const frameCount = this.data.length / frameSize;
			return new StaticMovie(
				Array.from({ length: frameCount }, (_, index) => {
					const rgbs = this.data.slice(index * frameSize, (index + 1) * frameSize);
					const colors = Array.from({ length: ledCount }, (_, index) => {
						return new THREE.Color(
							rgbs[index * 3 + 0] / 255.0,
							rgbs[index * 3 + 1] / 255.0,
							rgbs[index * 3 + 2] / 255.0,
						);
					});
					return new Frame(colors);
				}),
				fps,
			);
		}
	}

	/**
	 * @param {THREE.Scene} scene
	 */
	function setupScene(scene) {
		scene.clear();
		createAxes().forEach((obj) => scene.add(obj));
		scene.add(new THREE.AmbientLight(0x101010));
		//scene.add(buildBox());
		const strip = new Strip(
			new Strand(new Wire(), new LEDs(100, 0)),
			new Strand(new Wire(), new LEDs(100, 100)),
		);
		scene.add(strip);
		loadLayout(strip, "layouts/christmas-2023-detailed3d.json")
			.then(() => {
				//strip.frame = Frame.random(strip.ledCount);
				//strip.lit = true;
				//main.render();

				//startMovie(strip, "movies/generated-heart.raw");

				const movie = generateHeartMovie(strip, scene);
				const player = new MoviePlayer(strip, main.render.bind(main), movie);
				player.start();
				//saveByteArray("heart.raw", toRaw(movie));
			});
	}

	/**
	 * @return {THREE.LineSegments}
	 */
	function buildBox() {
		let geometry = new THREE.BoxGeometry(1, 1, 1);
		geometry.translate(0, 0.5, 0);
		let edges = new THREE.EdgesGeometry(geometry);
		let material = new THREE.LineBasicMaterial({ color: 0x444444 });
		return new THREE.LineSegments(edges, material);
	}

	/**
	 * @param {Strip} strip
	 * @param path
	 * @return {Promise<void>}
	 */
	function loadLayout(strip, path) {
		return fetch(path)
			.then((response) => response.json())
			.then((data) => {
				const layout = new Layout(data);
				layout.apply(strip);
				main.render();
			})
			;
	}

	/**
	 * @param {Strip} strip
	 * @param {string} path
	 */
	function startMovie(strip, path) {
		fetch(path)
			.then((response) => response.arrayBuffer())
			.then((data) => {
				const movie = new RawMovie(new Uint8Array(data)).toMovie(strip.ledCount, 15);
				const player = new MoviePlayer(strip, main.render.bind(main), movie);
				player.start();
			})
		;
	}

	/**
	 * @param {Strip} strip
	 */
	function generateRandomMovie(strip) {
		const player = new MoviePlayer(strip, main.render.bind(main), {
			get fps() {
				return 15;
			},

			get frameCount() {
				return 100;
			},

			get(index) {
				return Frame.random(strip.ledCount);
			},
		});
		player.start();
	}

	/**
	 * @param {THREE.Raycaster} raycaster
	 * @param {THREE.Object3D} object
	 * @param {THREE.Vector3} point
	 * @return {boolean}
	 */
	function isInside(raycaster, object, point) {
		raycaster.set(point, new THREE.Vector3(1, 1, 1));
		const intersects = raycaster.intersectObject(object, false);
		return intersects.length % 2 === 1;
	}

	/**
	 * @param {Strip} strip
	 * @param {THREE.Scene} scene
	 * @return {Frame}
	 */
	function generateHeartMovie(strip, scene) {
		const heart = new THREE.Group();
		const collision = new THREE.Mesh(
			new THREE.SphereGeometry(0.60, 12, 12),
			new THREE.MeshBasicMaterial({
				side: THREE.DoubleSide,
				visible: false,
			}),
		);
		heart.add(collision);
		heart.add(new THREE.LineSegments(
			new THREE.EdgesGeometry(collision.geometry),
			new THREE.LineBasicMaterial({
				color: 0xffff00,
				opacity: 0.05,
				transparent: true,
			}),
		));
		heart.add(new THREE.Mesh(
			new THREE.SphereGeometry(0.01),
			new THREE.MeshBasicMaterial({
				color: 0x00ff00,
			}),
		));
		heart.position.set(0, 0.6, 0);
		// mesh.visible = false;
		scene.add(heart);
		const movie = {
			get fps() {
				return 40;
			},

			get frameCount() {
				return 50;
			},

			get(index) {
				const frame = Frame.static(strip.ledCount, new THREE.Color(0xff7811));
				const raycaster = new THREE.Raycaster();
				const rMax = 0.65;
				heart.scale.set(rMax, rMax, rMax);
				heart.updateWorldMatrix(false, true);
				strip.leds
					.filter((led) => isInside(raycaster, collision, led.position))
					.forEach((led) => {
						frame.colors[led.index] = new THREE.Color(0, 0, 0);
					})
				;
				const r = 0.35 + 0.30 * Math.sin((index / this.frameCount) * 2 * 3.14);
				heart.scale.set(r, r, r);
				heart.updateWorldMatrix(false, true);
				strip.leds
					.filter((led) => isInside(raycaster, collision, led.position))
					.forEach((led) => {
						frame.colors[led.index] = new THREE.Color(0.5, 0, 0);
					})
				;
				return frame;
			},
		};
		return movie;
	}

	/**
	 * @param {Movie} movie
	 * @return {Uint8Array}
	 */
	function toRaw(movie) {
		const result = new Uint8Array(movie.frameCount * movie.get(0).colors.length * 3);
		for (let i = 0; i < movie.frameCount; i++) {
			const frame = movie.get(i);
			for (let c = 0; c < frame.colors.length; c++) {
				const color = frame.colors[c];
				result[(i * frame.colors.length + c) * 3 + 0] = Math.round(color.r * 255);
				result[(i * frame.colors.length + c) * 3 + 1] = Math.round(color.g * 255);
				result[(i * frame.colors.length + c) * 3 + 2] = Math.round(color.b * 255);
			}
		}
		return result;
	}

	// TODO get and send to strip directly: https://xled-docs.readthedocs.io/en/latest/rest_api.html
	/**
	 * @param {string} fileName
	 * @param {Uint8Array} byte
	 */
	function saveByteArray(fileName, byte) {
		const link = document.createElement('a');
		link.href = window.URL.createObjectURL(new Blob([ byte ], { type: "application/pdf" }));
		link.download = fileName;
		link.click();
	}

	/**
	 * @return {Array<THREE.AxesHelper>}
	 */
	function createAxes() {
		let positive = new THREE.AxesHelper(2);
		positive.material.transparent = true;
		positive.material.opacity = .01;
		let negative = new THREE.AxesHelper(2);
		negative.scale.set(-1, -1, -1);
		negative.material.vertexColors = false;
		negative.material.transparent = true;
		negative.material.opacity = .01;
		return [ positive, negative ];
	}

	let main = new Main();
	main.init();
	window.onresize = () => main.onResize();
	window.addEventListener('pointerdown', (event) => main.onPointerDown(event));
	window.addEventListener("mousemove", (event) => main.onPointerMove(event));
	main.render();
</script>
</body>
</html>

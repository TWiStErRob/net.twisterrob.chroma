<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			overflow: hidden;
			margin: 0;
		}
	</style>
</head>
<body>
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
		}
	}
</script>

<script type="module">
	"use strict";
	import * as THREE from 'three';

	THREE.ColorManagement.legacyMode = false;

	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

	class Main {
		params = {
			threshold: 0,
			strength: 1,
			radius: 0,
			exposure: 1,
		};

		init() {
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.outputColorSpace = THREE.SRGBColorSpace;
			document.body.appendChild(renderer.domElement);
			this.renderer = renderer;

			this.camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.01, 200);

			const controls = new OrbitControls(this.camera, renderer.domElement);
			controls.target = new THREE.Vector3(0, 1, 0);
			controls.object.position.set(1, 1.5, 2);
			controls.minDistance = 1;
			controls.maxDistance = 10;
			controls.update();
			controls.addEventListener('change', () => this.render());

			const scene = new THREE.Scene();
			setupScene(scene);
			this.scene = scene;

			const bloomPass = new UnrealBloomPass();
			bloomPass.threshold = this.params.threshold;
			bloomPass.strength = this.params.strength;
			bloomPass.radius = this.params.radius;
			this.bloomPass = bloomPass;

			const target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
				type: THREE.HalfFloatType,
				format: THREE.RGBAFormat,
				colorSpace: THREE.SRGBColorSpace,
				samples: 8,
			});
			const composer = new EffectComposer(renderer, target);
			composer.addPass(new RenderPass(scene, this.camera));
			composer.addPass(new ShaderPass(GammaCorrectionShader));
			composer.addPass(bloomPass);
			this.composer = composer;

			this.setupGui();
		}

		setupGui() {
			const gui = new GUI();

			const bloomFolder = gui.addFolder('bloom');

			const that = this;
			bloomFolder.add(this.params, 'threshold', 0.0, 1.0).onChange(function(value) {
				that.bloomPass.threshold = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'strength', 0.0, 3).onChange(function(value) {
				that.bloomPass.strength = Number(value);
				that.render();
			});

			bloomFolder.add(this.params, 'radius', 0.0, 1.0).step(0.01).onChange(function(value) {
				that.bloomPass.radius = Number(value);
				that.render();
			});

			const toneMappingFolder = gui.addFolder('tone mapping');

			toneMappingFolder.add(this.params, 'exposure', 0.1, 2).onChange(function(value) {
				that.renderer.toneMappingExposure = Math.pow(value, 4.0);
				that.render();
			});

			const environmentFolder = gui.addFolder('environment');

			environmentFolder.add(LED.geometry.parameters, 'radius', 0, 0.05).step(0.001).onChange(function(value) {
				LED.geometry = new THREE.SphereGeometry(value);
				setupScene(that.scene);
				that.render();
			});
		}

		onPointerDown(event) {
			if (this.hoveredLED) {
				this.hoveredLED.lit = !this.hoveredLED.lit;
				this.render();
			}
		}

		/** @type {LED|null} */
		hoveredLED = null;

		onPointerMove(event) {
			const currentObject = this.cast(event);
			if (this.hoveredLED === null && currentObject) {
				this.onEnter(currentObject);
				this.hoveredLED = currentObject;
				this.render();
			} else if (this.hoveredLED !== null && currentObject === null) {
				const existingObject = this.hoveredLED;
				this.hoveredLED = null;
				this.onExit(existingObject);
				this.render();
			} else if (this.hoveredLED !== null && currentObject !== null && this.hoveredLED !== currentObject) {
				const existingLED = this.hoveredLED;
				this.hoveredLED = null;
				this.onExit(existingLED);
				this.onEnter(currentObject);
				this.hoveredLED = currentObject;
				this.render();
			}
		}

		/** @param led {LED} */
		onEnter(led) {
			//console.log("enter", object);
			led.highlight = true;
		}

		/** @param led {LED} */
		onExit(led) {
			//console.log("exit", object);
			led.highlight = false;
		}

		cast(event) {
			const mouse = new THREE.Vector2(
				(event.clientX / window.innerWidth) * 2 - 1,
				-(event.clientY / window.innerHeight) * 2 + 1,
			);

			const raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, this.camera);
			const intersects = raycaster.intersectObjects(this.scene.children, false);
			const leds = intersects.filter((intersect) => intersect.object instanceof LED);
			if (leds.length > 0) {
				return leds[0].object;
			} else {
				return null;
			}
		}

		onResize() {
			const width = window.innerWidth;
			const height = window.innerHeight;

			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();

			this.renderer.setSize(width, height);
			this.composer.setSize(width, height);
			this.render();
		}

		render() {
			this.composer.render();
		}
	}

	class LED extends THREE.Mesh {
		static geometry = new THREE.SphereGeometry(0.015);

		constructor(position) {
			super(LED.geometry, LED.prepareMaterial());
			this.position.set(position.x, position.y, position.z);
		}

		static prepareMaterial() {
			const color = new THREE.Color();
			color.setHSL(Math.random(), 0.7, Math.random() * 0.2 + 0.05);

			return new THREE.MeshStandardMaterial({
				toneMapped: false,
				emissive: color,
				emissiveIntensity: 0,
			});
		}

		get color() {
			return this.material.emissive;
		}

		set color(value) {
			this.material.emissive = value;
		}

		get object() {
			return this;
		}

		get lit() {
			return this.material.emissiveIntensity > 0;
		}

		set lit(value) {
			this.material.emissiveIntensity = value? 1 : 0;
		}

		get highlight() {
			return this.material.userData.preHighlightIntensity !== undefined;
		}

		set highlight(value) {
			if (value) {
				this.material.userData.preHighlightIntensity = this.material.emissiveIntensity;
				this.material.emissiveIntensity = 4;
			} else if (this.highlight) {
				this.material.emissiveIntensity = this.material.userData.preHighlightIntensity;
				delete this.material.userData.preHighlightIntensity;
			}
		}
	}

	function setupScene(scene) {
		scene.clear();
		createAxes().forEach((obj) => scene.add(obj));
		scene.add(new THREE.AmbientLight(0x101010));
		scene.add(buildBox());
		startBuildLed(scene);
	}

	function buildBox() {
		let geometry = new THREE.BoxGeometry(1, 1, 1);
		geometry.translate(0, 0.5, 0);
		let edges = new THREE.EdgesGeometry(geometry);
		let material = new THREE.LineBasicMaterial({ color: 0x444444 });
		return new THREE.LineSegments(edges, material);
	}

	function startBuildLed(scene) {
		fetch("layouts/christmas-2023-detailed3d.json")
			.then((response) => response.json())
			.then((data) => {
				const coordinates = data;
				coordinates.forEach((c) => c.y *= 2);
				buildLed(coordinates).forEach((obj) => scene.add(obj));
				main.render();
			})
		;
	}

	/**
	 * @param {Array<{x,y,z}>} coordinates
	 * @return {Array<THREE.Object3D>}
	 */
	function buildLed(coordinates) {
		/** @type {Array<THREE.Object3D>} */
		const leds = coordinates.map((coordinate) => {
			const position = new THREE.Vector3(coordinate.x, coordinate.y, coordinate.z);
			let bulb = new LED(position);
			bulb.lit = Math.random() < 0.6;
			return bulb;
		});
		let midPoint = coordinates.length / 2;
		let strands = [
			buildStrand(coordinates.slice(undefined, midPoint)),
			buildStrand(coordinates.slice(midPoint, undefined)),
		];
		return leds.concat(strands);
	}

	/**
	 * @param {Array<{x,y,z}>} coordinates
	 * @return {THREE.Object3D}
	 */
	function buildStrand(coordinates) {
		const points = coordinates.map((coordinate) => new THREE.Vector3(coordinate.x, coordinate.y, coordinate.z));
		const positions = curve(points, 4);
		const geometry = new LineGeometry();
		geometry.setPositions(positions);

		const matLine = new LineMaterial({
			color: 0x080808,
			linewidth: .001,
		});

		const line = new Line2(geometry, matLine);
		line.computeLineDistances();
		line.scale.set(1, 1, 1);
		return line;
	}

	function createAxes() {
		let positive = new THREE.AxesHelper(2);
		positive.material.transparent = true;
		positive.material.opacity = .01;
		let negative = new THREE.AxesHelper(2);
		negative.scale.set(-1, -1, -1);
		negative.material.vertexColors = false;
		negative.material.transparent = true;
		negative.material.opacity = .01;
		return [ positive, negative ];
	}

	/**
	 * @param {Array<THREE.Vector3>} points
	 * @param {Number} divide
	 * @return {Array<Number>} [x,y,z, x,y,z, ...]
	 */
	function curve(points, divide) {
		const spline = new THREE.CatmullRomCurve3(points);
		const divisions = Math.round(divide * points.length);
		const point = new THREE.Vector3();
		const positions = [];
		for (let i = 0, l = divisions; i < l; i++) {
			const t = i / l;
			spline.getPoint(t, point);
			positions.push(point.x, point.y, point.z);
		}
		return positions;
	}

	let main = new Main();
	main.init();
	window.onresize = () => main.onResize();
	window.addEventListener('pointerdown', (event) => main.onPointerDown(event));
	window.addEventListener("mousemove", (event) => main.onPointerMove(event));
	main.render();
</script>
</body>
</html>
